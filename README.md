# Code Review

## CWE-598: Использование метода запроса GET с чувствительными строками запроса
Злоумышленники (как минимум) могут получить информацию из строк запроса, которую можно использовать для эскалации своего метода атаки, например информацию о внутренней работе приложения или именах столбцов базы данных. Успешное использование уязвимостей параметров строки запроса может привести к тому, что злоумышленник выдаст себя за законного пользователя, получит конфиденциальные данные или просто выполнит действия, не предусмотренные разработчиками приложения.
```php
$user = $_GET[ 'username' ];
$pass = $_GET[ 'password' ];
```

### Исправление:
При отправке чувствительной информации необходимо использовать метод `POST`
```php
$username = $_POST['username'];
$password = $_POST['password'];
```

## CWE-327: Использование устаревшего криптографического алгоритма MD5
```php
$pass = md5( $pass );
```
**MD5** больше не рекомендуется использовать, поскольку исследователи показали, что можно обойти систему, генерируя коллизии. Кроме того, производительность современных компьютеров позволяет любому взломать пароль путем перебора миллиардов паролей за достаточно короткий промежуток времени.

### Исправление:
Использовать более криптостойкий пароль - `SHA256`.
```php
$password_hash = hash($password + get_salt($username), $str);
```
> Разница между **MD5** и **SHA256** заключается в том, что **SHA256** труднее обрабатывать, чем **MD5**, из-за его размера. 
**MD5** — 128 бит, тогда как **SHA256** — 256 бит.

## CWE-759: Использование одностороннего хеширования без соли
Это упрощает для злоумышленников предварительное вычисление хеш-значения с использованием методов атаки по словарю.

В криптографии соль относится к некоторому случайному добавлению данных к входным данным перед хэшированием, чтобы затруднить атаки по словарю.

### Исправление:
Использовать соль, которая будет храниться в базе данных.
```php
get_salt($username)
```

## CWE-89: Неправильная нейтрализация специальных элементов, используемых в команде SQL
```php
$query  = "SELECT * FROM `users` WHERE user = '$user' AND password = '$pass';";
```

### Исправление:
Добавить использование PDO или его аналогов, чтобы избежать SQL инъекции.
```php
$data = prepare_data('SELECT * FROM users WHERE user = (:user) AND password = (:password) LIMIT 1;');
$data->bindParam($username_param, $username, PDO::PARAM_STR);
$data->bindParam($password_param, $password_hash, PDO::PARAM_STR);
$row = get_row($data);
```

## CWE-307: Неправильное ограничение или отсутствия чрезмерных попыток аутентификации
Злоумышленник может выполнить произвольное количество попыток аутентификации, используя разные пароли, и в конечном итоге получить доступ к целевой учетной записи.

### Исправление:
Возможные варианты исправления ошибок:
 - Отключение пользователя после небольшого количества неудачных попыток
 - Реализация тайм-аута
 - Блокировка целевой учетной записи
 - Требование вычислительной задачи со стороны пользователя.

Отключение пользователя после небольшого количества неудачных попыток.
```php
if($row == 1) {
	$avatar = $row["avatar"];
	$html .= "<p>Welcome to the password protected area {$username}</p>";
	$html .= "<img src=\"{$avatar}\" />";

	$query = "UPDATE users SET {$failed_login_count} = null WHERE user = (:user) AND password = (:password) LIMIT 1;"
	$data = prepare_data($query);
	$data->bindParam($username_param, $username, PDO::PARAM_STR);
	$data->execute();
} else {
	$data = prepare_data("UPDATE users SET {$failed_login_count} = ({$failed_login_count} + 1) WHERE user = (:user) LIMIT 1;");
	$data->bindParam($username_param, $username, PDO::PARAM_STR);
	$data->execute();

	$html .= "<pre>";
	$html .= "Username and/or password incorrect.<br/>";
	$html .= "Please try again after {$lockout_time} minutes<br/>";
	$html .= "</pre>";
	sleep($lockout_time);
}
```

## CWE-472: внешний контроль предполагаемого неизменяемого веб-параметра
Веб-приложение недостаточно проверяет входные данные, которые считаются неизменяемыми, но на самом деле могут контролироваться извне, например скрытые поля формы.
### Исправление:
 ```php
function check_unacceptable_symbols($input) {
	$unacceptable_symbols = array('"', '\'', '--', '*');
	foreach ($unacceptable_symbols as $symbol) {
		if (!str_contains($username, $symbol)) continue;
		$html .= "<pre><br/>Username and/or password contains unacceptable symbols: {$symbol}.</pre>";
		return true;
	}
	return false;
}
```

## CWE-79: Неправильная нейтрализация ввода во время создания веб-страницы («Межсайтовый скриптинг»)
Наиболее распространенная атака, выполняемая с помощью межсайтового скриптинга, связана с раскрытием информации, хранящейся в пользовательских файлах *cookie*. Как правило, злоумышленник создает сценарий на стороне клиента, который при анализе веб-браузером выполняет определенные действия (например, отправляет все файлы cookie сайта на заданный адрес электронной почты). Этот сценарий будет загружаться и запускаться каждым пользователем, посещающим веб-сайт. Поскольку сайт, запрашивающий запуск сценария, имеет доступ к рассматриваемым файлам cookie, вредоносный сценарий также имеет доступ к ним.
### Исправление:
 ```php
$user = htmlspecialchars ($_POST[ 'username' ]);
$pass = htmlspecialchars ($_POST[ 'password' )];
```
